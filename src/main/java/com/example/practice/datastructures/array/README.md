## 개요
배열은 연속적인 메모리 구조로 이루어진 자료구조입니다. 이는 메모리 주소를 활용하여 특별한 연산들을 수행할 수 있습니다. 1차원 배열부터 다차원 배열까지 활용할 수 있습니다.

## 배열의 강점
배열의 가장 큰 강점은 인덱스로 접근이 가능하다는 것입니다. 이는 배열은 결국 할당받은 연속적인 메모리의 시작 위치를 나타나고, 인덱스는 위치 정보를 나타내기 때문입니다.

배열의 특정 요소를 인덱스를 활용하여 O(1) 시간 복잡도로 접근하고 값을 수정할 수 있습니다

## 다차원 배열의 인덱싱
다차원 배열은 arr[0][5]와 같이 접근을 할 수 있는데요, 이를 구현하는 방식은 대표적으로 Row-major, Column-major이 존재합니다.

Row-major은 (0, 0) (0, 1) (1, 0) (1, 1)과 같이 행을 우선적으로 요소들을 배치하는 것을 말합니다.

Column-major은 (0, 0) (1, 0) (0 1) (1, 1)과 같이 열을 우선적으로 요소들을 배치합니다.

## 배열의 시간복잡도
- Read: O(1)
- Write: O(1)
- Append: 최종 요소는 O(1), 그 외에는 O(N)
- Delete: 최종 요소는 O(1), 그 외에는 O(N)

## 동적 배열
Append와 Delete는 사실 정적 배열에서는 불가능합니다. 배열은 연속적인 메모리로 이루어진 자료구조이기 때문입니다. 초기에 할당한 영역 이후에 메모리가 비어있는지 사용중인지를 확인할 수 없습니다.

추가할 요소에 존재하는 메모리가 다른 곳에서 사용하는지 안하는지 보장할 수 없기 때문에 정적 배열에서는 요소에 추가를 제공할 수 없습니다.

해당 문제를 해결하기 위해 등장한 자료구조가 동적 배열입니다.

Java에서는 Collection 프레임워크의 ArrayList, Python List, C++ Vector가 이를 구현합니다.

<br>

> 동적 배열의 원리

동적 배열은 내부적으로 size, capacity를 가지고 최대 용량에 도달하면 resize를 수행하는 것으로 동작하게 됩니다.

또한 고차원 배열의 경우 인덱스별로 이것이 이루어지게 됩니다.

resize는 기존 배열보다 일정 이상 큰 배열을 새로 선언하고 기존 배열의 요소를 모두 복사하고 메모리 포인터를 교체하는 것으로 동작하게 됩니다.

동적 배열의 연산별 시간복잡도는 다음과 같습니다.
- get O(1)
- set O(1)
- pushback O(N)
- remove O(N)
- size O(1)

여기서 pushback에 경우에는 평균적으로는 O(1)의 시간복잡도를 기대할 수 있지만, resize가 발생할 경우에는 O(n) 복잡도로 이루어지게 됩니다.

## 정적 배열
정적 배열은 고정된 크기의 배열입니다. 

언어별로 메모리 할당 영역과 차이가 존재하는데요, C언어의 경우 컴파일 시점에 스택 메모리를 할당하고 코드 블록 상에서 생명주기를 관리합니다.

하지만 Java의 경우 GC와 같이 자동 힙 메모리 관리를 제공하기 때문에 런타임 시점에 힙 메모리 할당으로 이루어집니다.
